{{#each resources}}///<reference path='./resources/{{{name}}}.d.ts' />
{{/each}}///<reference path='./resources/Content.d.ts' />
///<reference path='./resources/WebhookEvent.d.ts' />
declare module 'chargebee' {
  export type Config = {
    /**
     * @apiKey api key for the site.
     */
    apiKey: string;
    /**
     * @site api site name.
     */
    site: string;
    /**
     * @apiPath this value indicates the api version, default value is /api/v2.
     */
    apiPath?: '/api/v2' | '/api/v1';
    /**
     * @timeout client side request timeout in milliseconds, default value is 80000ms.
     */
    timeout?: number;
    /**
     * @port url port
     */
    port?: number;
    /**
     * @timemachineWaitInMillis time interval at which two subsequent retrieve timemachine call in milliseconds, default value is 3000ms.
     */
    timemachineWaitInMillis?: number;
    /**
     * @exportWaitInMillis time interval at which two subsequent retrieve export call in milliseconds, default value is 3000ms.
     */
    exportWaitInMillis?: number;
    /**
     * @protocol http protocol, default value is https
     */
    protocol?: 'https' | 'http';
    /**
     * @hostSuffix url host suffix, default value is .chargebee.com
     */
    hostSuffix?: string;

    /**
     * @retryConfig retry configuration for the client, default value is { enabled: false, maxRetries: 3, delayMs: 1000, retryOn: [500, 502, 503, 504]}
     */
    retryConfig?: RetryConfig;

    /**
     * @enableDebugLogs whether to enable debug logs, default value is false
     */
    enableDebugLogs?: boolean;

    /**
     * @userAgentSuffix optional string appended to the User-Agent header for additional logging
     */
    userAgentSuffix?: string;

    /**
     * @httpClient optional http client implementation, default http client will be used if not provided
     */
    httpClient?: HttpClientInterface;
  };

  export interface HttpClientInterface {
    makeApiRequest: (request: Request, timeout: number) => Promise<Response>;
  }

  export type RetryConfig = {
    /**
     * @enabled whether to enable retry logic, default value is false
     * @maxRetries maximum number of retries, default value is 3
     * @delayMs delay in milliseconds between retries, default value is 1000ms
     * @retryOn array of HTTP status codes to retry on, default value is [500, 502, 503, 504]
     */
    enabled?: boolean;
    maxRetries?: number;
    delayMs?: number;
    retryOn?: Array<number>;
  };

  export default class Chargebee {
    constructor(config: Config);
    {{#each resources}}{{#if hasActions}} {{snakeCaseToCamelCaseAndSingularize id}}: {{name}}.{{name}}Resource;
    {{/if}}{{/each}}
  }

  // Webhook Handler
  export type WebhookEventType = EventTypeEnum | 'unhandled_event';
  export type WebhookContentTypeValue = `${WebhookContentType}`;
  export type WebhookEventListener<T extends WebhookContentType = WebhookContentType> = (event: WebhookEvent<T>) => Promise<void> | void;
  export type WebhookErrorListener = (error: Error) => Promise<void> | void;

  // Helper type to map string literal to enum member
  type StringToWebhookContentType<S extends WebhookContentTypeValue> = {
    [K in WebhookContentType]: `${K}` extends S ? K : never
  }[WebhookContentType];

  export class WebhookHandler {
    on<T extends WebhookContentType>(eventName: T, listener: WebhookEventListener<T>): this;
    on<S extends WebhookContentTypeValue>(eventName: S, listener: WebhookEventListener<StringToWebhookContentType<S>>): this;
    on(eventName: 'unhandled_event', listener: WebhookEventListener): this;
    on(eventName: 'error', listener: WebhookErrorListener): this;
    once<T extends WebhookContentType>(eventName: T, listener: WebhookEventListener<T>): this;
    once<S extends WebhookContentTypeValue>(eventName: S, listener: WebhookEventListener<StringToWebhookContentType<S>>): this;
    once(eventName: 'unhandled_event', listener: WebhookEventListener): this;
    once(eventName: 'error', listener: WebhookErrorListener): this;
    off<T extends WebhookContentType>(eventName: T, listener: WebhookEventListener<T>): this;
    off<S extends WebhookContentTypeValue>(eventName: S, listener: WebhookEventListener<StringToWebhookContentType<S>>): this;
    off(eventName: 'unhandled_event', listener: WebhookEventListener): this;
    off(eventName: 'error', listener: WebhookErrorListener): this;
    handle(
      body: string | object,
      headers?: Record<string, string | string[] | undefined>,
    ): void;
    onError?: (error: any) => void;
    requestValidator?: (
      headers: Record<string, string | string[] | undefined>,
    ) => void;
  }

  // Webhook Auth
  export function basicAuthValidator(
    validateCredentials: (username: string, password: string) => boolean,
  ): (headers: Record<string, string | string[] | undefined>) => void;

  // Default webhook handler instance
  export const webhook: WebhookHandler;

}