{{#each resources}}///<reference path='./resources/{{{name}}}.d.ts' />
{{/each}}///<reference path='./resources/Content.d.ts' />
///<reference path='./resources/WebhookEvent.d.ts' />
declare module 'chargebee' {
  export type Config = {
    /**
     * @apiKey api key for the site.
     */
    apiKey: string;
    /**
     * @site api site name.
     */
    site: string;
    /**
     * @apiPath this value indicates the api version, default value is /api/v2.
     */
    apiPath?: '/api/v2' | '/api/v1';
    /**
     * @timeout client side request timeout in milliseconds, default value is 80000ms.
     */
    timeout?: number;
    /**
     * @port url port
     */
    port?: number;
    /**
     * @timemachineWaitInMillis time interval at which two subsequent retrieve timemachine call in milliseconds, default value is 3000ms.
     */
    timemachineWaitInMillis?: number;
    /**
     * @exportWaitInMillis time interval at which two subsequent retrieve export call in milliseconds, default value is 3000ms.
     */
    exportWaitInMillis?: number;
    /**
     * @protocol http protocol, default value is https
     */
    protocol?: 'https' | 'http';
    /**
     * @hostSuffix url host suffix, default value is .chargebee.com
     */
    hostSuffix?: string;

    /**
     * @retryConfig retry configuration for the client, default value is { enabled: false, maxRetries: 3, delayMs: 1000, retryOn: [500, 502, 503, 504]}
     */
    retryConfig?: RetryConfig;

    /**
     * @enableDebugLogs whether to enable debug logs, default value is false
     */
    enableDebugLogs?: boolean;

    /**
     * @userAgentSuffix optional string appended to the User-Agent header for additional logging
     */
    userAgentSuffix?: string;

    /**
     * @httpClient optional http client implementation, default http client will be used if not provided
     */
    httpClient?: HttpClientInterface;
  };

  export interface HttpClientInterface {
    makeApiRequest: (request: Request, timeout: number) => Promise<Response>;
  }

  export type RetryConfig = {
    /**
     * @enabled whether to enable retry logic, default value is false
     * @maxRetries maximum number of retries, default value is 3
     * @delayMs delay in milliseconds between retries, default value is 1000ms
     * @retryOn array of HTTP status codes to retry on, default value is [500, 502, 503, 504]
     */
    enabled?: boolean;
    maxRetries?: number;
    delayMs?: number;
    retryOn?: Array<number>;
  };

  export default class Chargebee {
    constructor(config: Config);
    {{#each resources}}{{#if hasActions}} {{snakeCaseToCamelCaseAndSingularize id}}: {{name}}.{{name}}Resource;
    {{/if}}{{/each}}
    /** Webhook handler instance with auto-configured Basic Auth (if env vars are set) */
    webhooks: WebhookHandler & {
      /** Create a new typed webhook handler instance */
      createHandler<ReqT = unknown, ResT = unknown>(options?: WebhookHandlerOptions): WebhookHandler<ReqT, ResT>;
    };
  }

  // Webhook Handler Types
  export type WebhookEventName = EventTypeEnum | 'unhandled_event';
  export type WebhookEventTypeValue = `${WebhookEventType}`;
  /** @deprecated Use WebhookEventTypeValue instead */
  export type WebhookContentTypeValue = WebhookEventTypeValue;

  /**
   * Context object passed to webhook event listeners.
   * Wraps the event data with optional framework-specific request/response objects.
   */
  export interface WebhookContext<ReqT = unknown, ResT = unknown> {
    /** The parsed webhook event from Chargebee */
    event: WebhookEvent;
    /** Framework-specific request object (Express, Fastify, etc.) */
    request?: ReqT;
    /** Framework-specific response object (Express, Fastify, etc.) */
    response?: ResT;
  }

  /**
   * Validator function type for authenticating webhook requests.
   * Can be synchronous or asynchronous.
   */
  export type RequestValidator = (
    headers: Record<string, string | string[] | undefined>,
  ) => void | Promise<void>;

  /**
   * Configuration options for WebhookHandler.
   */
  export interface WebhookHandlerOptions {
    /**
     * Optional validator function to authenticate incoming webhook requests.
     * Typically used for Basic Auth validation.
     * Can be sync or async - throw an error to reject the request.
     */
    requestValidator?: RequestValidator;
  }

  /**
   * Options for the handle() method.
   */
  export interface HandleOptions<ReqT = unknown, ResT = unknown> {
    /** The raw request body (string) or pre-parsed object */
    body: string | object;
    /** Optional HTTP headers for validation */
    headers?: Record<string, string | string[] | undefined>;
    /** Optional framework-specific request object (Express, Fastify, etc.) */
    request?: ReqT;
    /** Optional framework-specific response object (Express, Fastify, etc.) */
    response?: ResT;
  }

  export type WebhookEventListener<ReqT = unknown, ResT = unknown, T extends WebhookEventType = WebhookEventType> = (context: WebhookContext<ReqT, ResT> & { event: WebhookEvent<T> }) => Promise<void> | void;
  export type WebhookErrorListener = (error: Error) => Promise<void> | void;

  // Helper type to map string literal to enum member
  type StringToWebhookEventType<S extends WebhookEventTypeValue> = {
    [K in WebhookEventType]: `${K}` extends S ? K : never
  }[WebhookEventType];

  export interface WebhookHandler<ReqT = unknown, ResT = unknown> {
    on<T extends WebhookEventType>(eventName: T, listener: WebhookEventListener<ReqT, ResT, T>): this;
    on<S extends WebhookEventTypeValue>(eventName: S, listener: WebhookEventListener<ReqT, ResT, StringToWebhookEventType<S>>): this;
    on(eventName: 'unhandled_event', listener: WebhookEventListener<ReqT, ResT>): this;
    on(eventName: 'error', listener: WebhookErrorListener): this;
    once<T extends WebhookEventType>(eventName: T, listener: WebhookEventListener<ReqT, ResT, T>): this;
    once<S extends WebhookEventTypeValue>(eventName: S, listener: WebhookEventListener<ReqT, ResT, StringToWebhookEventType<S>>): this;
    once(eventName: 'unhandled_event', listener: WebhookEventListener<ReqT, ResT>): this;
    once(eventName: 'error', listener: WebhookErrorListener): this;
    off<T extends WebhookEventType>(eventName: T, listener: WebhookEventListener<ReqT, ResT, T>): this;
    off<S extends WebhookEventTypeValue>(eventName: S, listener: WebhookEventListener<ReqT, ResT, StringToWebhookEventType<S>>): this;
    off(eventName: 'unhandled_event', listener: WebhookEventListener<ReqT, ResT>): this;
    off(eventName: 'error', listener: WebhookErrorListener): this;
    handle(options: HandleOptions<ReqT, ResT>): Promise<void>;
    requestValidator: RequestValidator | undefined;
  }

  // Webhook Auth
  /**
   * Credential validator function type.
   * Can be synchronous or asynchronous (e.g., for database lookups).
   */
  export type CredentialValidator = (
    username: string,
    password: string,
  ) => boolean | Promise<boolean>;

  /**
   * Creates a Basic Auth validator for webhook requests.
   */
  export function basicAuthValidator(
    validateCredentials: CredentialValidator,
  ): (headers: Record<string, string | string[] | undefined>) => Promise<void>;

}