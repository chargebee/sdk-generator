/*
 * This file is auto-generated by Chargebee.
 * For more information on how to make changes to this file, please see the README.
 * Reach out to dx@chargebee.com for any questions.
 * Copyright 2025 Chargebee Inc.
 */

package com.chargebee.v4.services;

import com.chargebee.v4.services.BaseService;
import com.chargebee.v4.services.ServiceConfig;
import com.chargebee.v4.client.ChargebeeClient;
import com.chargebee.v4.client.request.RequestOptions;
import com.chargebee.v4.exceptions.ChargebeeException;
import com.chargebee.v4.transport.Response;
import java.util.Map;
import java.util.List;
import java.util.concurrent.CompletableFuture;
{{#each operations}}
{{#unless batchOperation}}
import com.chargebee.v4.models.{{../packageName}}.params.{{paramsClassName}};
{{/unless}}
{{/each}}
{{#each operations}}
{{#unless batchOperation}}
import com.chargebee.v4.models.{{../packageName}}.responses.{{returnType}};
{{/unless}}
{{/each}}
{{#if hasBatchOperations}}
import com.chargebee.v4.internal.BatchRequest;
{{/if}}
{{#if hasSubDomainOperations}}
import com.chargebee.v4.internal.SubDomain;
{{/if}}
{{#if (eq name "TimeMachine")}}
import com.chargebee.v4.models.timeMachine.TimeMachine;
import com.chargebee.v4.models.timeMachine.TimeMachine.TimeTravelStatus;
import com.chargebee.v4.exceptions.OperationFailedException;
import com.chargebee.v4.exceptions.codes.BadRequestApiErrorCode;
import com.chargebee.v4.internal.JsonUtil;
{{/if}}


public final class {{name}}Service extends BaseService<{{name}}Service> {
    
    private final ServiceConfig config;

    public {{name}}Service(ChargebeeClient client) {
        super(client);
        this.config = ServiceConfig.defaultConfig();
    }
    
    private {{name}}Service(ChargebeeClient client, RequestOptions options) {
        super(client, options);
        this.config = ServiceConfig.defaultConfig();
    }
    
    private {{name}}Service(ChargebeeClient client, RequestOptions options, ServiceConfig config) {
        super(client, options);
        this.config = config;
    }
    
    @Override
    {{name}}Service with(RequestOptions newOptions) {
        return new {{name}}Service(client, newOptions, config);
    }
    
    /**
     * Apply per-request options for this service instance.
     * Users can chain .withOptions or .options to set headers and other options.
     */
    public {{name}}Service withOptions(RequestOptions options) {
        return with(options);
    }
    
    // === Operations ===
    {{#each operations}}
    {{#if batchOperation}}

    /**
     * Batch {{methodName}} operation for {{../packageName}}.
     * Returns a BatchRequest that can be populated with entries and executed.
     *
     * @return BatchRequest builder for batch execution
     */
    public BatchRequest {{batchMethodName}}() {
        {{#if hasSubDomain}}
        return new BatchRequest("{{batchUri}}", {{#if batchPathId}}"{{batchPathId}}"{{else}}null{{/if}}, {{subDomainEnumRef}}, client);
        {{else}}
        return new BatchRequest("{{batchUri}}", {{#if batchPathId}}"{{batchPathId}}"{{else}}null{{/if}}, client);
        {{/if}}
    }

    {{else}}
    {{#if hasPathParams}}
    {{#if isListResponse}}
    
    /**
     * {{methodName}} a {{../packageName}} using immutable params (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}, {{paramsClassName}} params) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}getWithSubDomain(path, {{subDomainEnumRef}}.getValue(), params != null ? params.toQueryParams() : null){{else}}get(path, params != null ? params.toQueryParams() : null){{/if}};
    }

    /**
     * {{methodName}} a {{../packageName}} without params (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}getWithSubDomain(path, {{subDomainEnumRef}}.getValue(), null){{else}}get(path, null){{/if}};
    }

    /**
     * {{methodName}} a {{../packageName}} using raw JSON payload (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}, String jsonPayload) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        throw new UnsupportedOperationException("JSON payload not supported for GET operations");
    }

    public {{returnType}} {{methodName}}(String {{pathParamName}}, {{paramsClassName}} params) throws ChargebeeException {
        Response response = {{methodName}}Raw({{pathParamName}}, params);
        return {{returnType}}.fromJson(response.getBodyAsString(), this, params, {{pathParamName}}, response);
    }

    public {{returnType}} {{methodName}}(String {{pathParamName}}) throws ChargebeeException {
        Response response = {{methodName}}Raw({{pathParamName}});
        return {{returnType}}.fromJson(response.getBodyAsString(), this, null, {{pathParamName}}, response);
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} with params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async(String {{pathParamName}}, {{paramsClassName}} params) {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}getWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), params != null ? params.toQueryParams() : null){{else}}getAsync(path, params != null ? params.toQueryParams() : null){{/if}}.thenApply(response -> {{returnType}}.fromJson(response.getBodyAsString(), this, params, {{pathParamName}}, response));
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} without params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async(String {{pathParamName}}) {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}getWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), null){{else}}getAsync(path, null){{/if}}.thenApply(response -> {{returnType}}.fromJson(response.getBodyAsString(), this, null, {{pathParamName}}, response));
    }

    {{else}}
    
    /**
     * {{methodName}} a {{../packageName}} (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        {{#if (eq httpMethod "post")}}
        return {{#if hasSubDomain}}postWithSubDomain(path, {{subDomainEnumRef}}.getValue(), null){{else}}post(path, null){{/if}};
        {{else}}
        return {{#if hasSubDomain}}getWithSubDomain(path, {{subDomainEnumRef}}.getValue(), null){{else}}get(path, null){{/if}};
        {{/if}}
    }

    {{#if (and (eq httpMethod "post") hasRequestBody)}}
    /**
     * {{methodName}} a {{../packageName}} using immutable params (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}, {{paramsClassName}} params) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if isOperationNeedsJsonInput}}{{#if hasSubDomain}}postJsonWithSubDomain(path, {{subDomainEnumRef}}.getValue(), params != null ? params.toJsonString() : null){{else}}postJson(path, params != null ? params.toJsonString() : null){{/if}}{{else}}{{#if hasSubDomain}}postWithSubDomain(path, {{subDomainEnumRef}}.getValue(), params.toFormData()){{else}}post(path, params.toFormData()){{/if}}{{/if}};
    }

    /**
     * {{methodName}} a {{../packageName}} using raw JSON payload (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}, String jsonPayload) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}postJsonWithSubDomain(path, {{subDomainEnumRef}}.getValue(), jsonPayload){{else}}postJson(path, jsonPayload){{/if}};
    }

    public {{returnType}} {{methodName}}(String {{pathParamName}}, {{paramsClassName}} params) throws ChargebeeException {
        Response response = {{methodName}}Raw({{pathParamName}}, params);
        return {{returnType}}.fromJson(response.getBodyAsString(), response);
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} with params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async(String {{pathParamName}}, {{paramsClassName}} params) {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if isOperationNeedsJsonInput}}{{#if hasSubDomain}}postJsonWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), params != null ? params.toJsonString() : null){{else}}postJsonAsync(path, params != null ? params.toJsonString() : null){{/if}}{{else}}{{#if hasSubDomain}}postWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), params.toFormData()){{else}}postAsync(path, params.toFormData()){{/if}}{{/if}}.thenApply(response -> {{returnType}}.fromJson(response.getBodyAsString(), response));
    }
    {{/if}}

    {{#if (and (eq httpMethod "get") hasQueryParams)}}
    /**
     * {{methodName}} a {{../packageName}} using immutable params (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String {{pathParamName}}, {{paramsClassName}} params) throws ChargebeeException {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}getWithSubDomain(path, {{subDomainEnumRef}}.getValue(), params != null ? params.toQueryParams() : null){{else}}get(path, params != null ? params.toQueryParams() : null){{/if}};
    }

    public {{returnType}} {{methodName}}(String {{pathParamName}}, {{paramsClassName}} params) throws ChargebeeException {
        Response response = {{methodName}}Raw({{pathParamName}}, params);
        return {{returnType}}.fromJson(response.getBodyAsString(), response);
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} with params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async(String {{pathParamName}}, {{paramsClassName}} params) {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        return {{#if hasSubDomain}}getWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), params != null ? params.toQueryParams() : null){{else}}getAsync(path, params != null ? params.toQueryParams() : null){{/if}}.thenApply(response -> {{returnType}}.fromJson(response.getBodyAsString(), response));
    }
    {{/if}}

    {{!-- Generate no-params method if: not a POST with body, OR all body params are optional --}}
    {{#if (or (not (and (eq httpMethod "post") hasRequestBody)) isAllRequestBodyParamsOptional)}}
    public {{returnType}} {{methodName}}(String {{pathParamName}}) throws ChargebeeException {
        Response response = {{methodName}}Raw({{pathParamName}});
        return {{returnType}}.fromJson(response.getBodyAsString(), response);
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} without params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async(String {{pathParamName}}) {
        String path = buildPathWithParams("{{path}}", "{{pathParam}}", {{pathParamName}});
        {{#if (eq httpMethod "post")}}
        return {{#if isOperationNeedsJsonInput}}{{#if hasSubDomain}}postJsonWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), null){{else}}postJsonAsync(path, null){{/if}}{{else}}{{#if hasSubDomain}}postWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), null){{else}}postAsync(path, null){{/if}}{{/if}}.thenApply(response -> {{returnType}}.fromJson(response.getBodyAsString(), response));
        {{else}}
        return {{#if hasSubDomain}}getWithSubDomainAsync(path, {{subDomainEnumRef}}.getValue(), null){{else}}getAsync(path, null){{/if}}.thenApply(response -> {{returnType}}.fromJson(response.getBodyAsString(), response));
        {{/if}}
    }
    {{/if}}

    {{/if}}
    {{else}}
    
    /**
     * {{methodName}} a {{../packageName}} using immutable params (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw({{paramsClassName}} params) throws ChargebeeException {
        {{#if (eq httpMethod "post")}}
        return {{#if isOperationNeedsJsonInput}}{{#if hasSubDomain}}postJsonWithSubDomain("{{path}}", {{subDomainEnumRef}}.getValue(), params != null ? params.toJsonString() : null){{else}}postJson("{{path}}", params != null ? params.toJsonString() : null){{/if}}{{else}}{{#if hasSubDomain}}postWithSubDomain("{{path}}", {{subDomainEnumRef}}.getValue(), params != null ? params.toFormData() : null){{else}}post("{{path}}", params != null ? params.toFormData() : null){{/if}}{{/if}};
        {{else}}
        return {{#if hasSubDomain}}getWithSubDomain("{{path}}", {{subDomainEnumRef}}.getValue(), params != null ? params.toQueryParams() : null){{else}}get("{{path}}", params != null ? params.toQueryParams() : null){{/if}};
        {{/if}}
    }

    {{#if (or isListResponse isAllQueryParamsOptional)}}
    /**
     * {{methodName}} a {{../packageName}} without params (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw() throws ChargebeeException {
        {{#if (eq httpMethod "post")}}
        return {{#if hasSubDomain}}postWithSubDomain("{{path}}", {{subDomainEnumRef}}.getValue(), null){{else}}post("{{path}}", null){{/if}};
        {{else}}
        return {{#if hasSubDomain}}getWithSubDomain("{{path}}", {{subDomainEnumRef}}.getValue(), null){{else}}get("{{path}}", null){{/if}};
        {{/if}}
    }
    {{/if}}

    /**
     * {{methodName}} a {{../packageName}} using raw JSON payload (executes immediately) - returns raw Response.
     */
    Response {{methodName}}Raw(String jsonPayload) throws ChargebeeException {
        {{#if (eq httpMethod "post")}}
        return {{#if hasSubDomain}}postJsonWithSubDomain("{{path}}", {{subDomainEnumRef}}.getValue(), jsonPayload){{else}}postJson("{{path}}", jsonPayload){{/if}};
        {{else}}
        throw new UnsupportedOperationException("JSON payload not supported for GET operations");
        {{/if}}
    }

    public {{returnType}} {{methodName}}({{paramsClassName}} params) throws ChargebeeException {
        Response response = {{methodName}}Raw(params);
        {{#if isListResponse}}
        return {{returnType}}.fromJson(response.getBodyAsString(), this, params, response);
        {{else}}
        return {{returnType}}.fromJson(response.getBodyAsString(), response);
        {{/if}}
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} with params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async({{paramsClassName}} params) {
        {{#if (eq httpMethod "post")}}
        return {{#if isOperationNeedsJsonInput}}{{#if hasSubDomain}}postJsonWithSubDomainAsync("{{path}}", {{subDomainEnumRef}}.getValue(), params != null ? params.toJsonString() : null){{else}}postJsonAsync("{{path}}", params != null ? params.toJsonString() : null){{/if}}{{else}}{{#if hasSubDomain}}postWithSubDomainAsync("{{path}}", {{subDomainEnumRef}}.getValue(), params != null ? params.toFormData() : null){{else}}postAsync("{{path}}", params != null ? params.toFormData() : null){{/if}}{{/if}}.thenApply(response -> {{#if isListResponse}}{{returnType}}.fromJson(response.getBodyAsString(), this, params, response){{else}}{{returnType}}.fromJson(response.getBodyAsString(), response){{/if}});
        {{else}}
        return {{#if hasSubDomain}}getWithSubDomainAsync("{{path}}", {{subDomainEnumRef}}.getValue(), params != null ? params.toQueryParams() : null){{else}}getAsync("{{path}}", params != null ? params.toQueryParams() : null){{/if}}.thenApply(response -> {{#if isListResponse}}{{returnType}}.fromJson(response.getBodyAsString(), this, params, response){{else}}{{returnType}}.fromJson(response.getBodyAsString(), response){{/if}});
        {{/if}}
    }

    {{#if (or isListResponse isAllQueryParamsOptional)}}
    public {{returnType}} {{methodName}}() throws ChargebeeException {
        Response response = {{methodName}}Raw();
        {{#if isListResponse}}
        return {{returnType}}.fromJson(response.getBodyAsString(), this, null, response);
        {{else}}
        return {{returnType}}.fromJson(response.getBodyAsString(), response);
        {{/if}}
    }

    /**
     * Async variant of {{methodName}} for {{../packageName}} without params.
     */
    public CompletableFuture<{{returnType}}> {{methodName}}Async() {
        {{#if (eq httpMethod "post")}}
        return {{#if hasSubDomain}}postWithSubDomainAsync("{{path}}", {{subDomainEnumRef}}.getValue(), null){{else}}postAsync("{{path}}", null){{/if}}.thenApply(response -> {{#if isListResponse}}{{returnType}}.fromJson(response.getBodyAsString(), this, null, response){{else}}{{returnType}}.fromJson(response.getBodyAsString(), response){{/if}});
        {{else}}
        return {{#if hasSubDomain}}getWithSubDomainAsync("{{path}}", {{subDomainEnumRef}}.getValue(), null){{else}}getAsync("{{path}}", null){{/if}}.thenApply(response -> {{#if isListResponse}}{{returnType}}.fromJson(response.getBodyAsString(), this, null, response){{else}}{{returnType}}.fromJson(response.getBodyAsString(), response){{/if}});
        {{/if}}
    }
    {{/if}}

    {{/if}}
    {{/if}}
    {{/each}}
{{#if (eq name "Export")}}
    // === Export Utility Methods ===
    
    /**
     * Waits for an export operation to complete by polling its status.
     * Polls every 10 seconds (configurable via cb.java.export.sleep.millis system property).
     * 
     * @param export The export to wait for (must have a valid ID)
     * @return The completed Export object with COMPLETED or FAILED status
     * @throws ChargebeeException if API call fails during polling
     * @throws RuntimeException if export takes too long (over 50 polling attempts)
     * @throws InterruptedException if thread is interrupted while waiting
     */
    public com.chargebee.v4.models.export.Export waitForExportCompletion(
            com.chargebee.v4.models.export.Export export) 
            throws ChargebeeException, InterruptedException {
        int count = 0;
        int sleepTime = Integer.getInteger("cb.java.export.sleep.millis", 10000);
        com.chargebee.v4.models.export.Export currentExport = export;
        
        while (currentExport.getStatus() == com.chargebee.v4.models.export.Export.Status.IN_PROCESS) {
            if (count++ > 50) {
                throw new RuntimeException("Export is taking too long");
            }
            Thread.sleep(sleepTime);
            ExportRetrieveResponse response = retrieve(currentExport.getId());
            currentExport = response.getExport();
        }
        return currentExport;
    }
{{/if}}
{{#if (eq name "TimeMachine")}}
    // === Time Travel Completion Helper ===
    
    /**
     * Waits for time travel operation to complete.
     * Polls the API until the status changes from IN_PROGRESS.
     *
     * @param timeMachine The TimeMachine instance to wait for
     * @return The updated TimeMachine with final status
     * @throws ChargebeeException if the API call fails
     * @throws InterruptedException if the thread is interrupted while waiting
     * @throws RuntimeException if time travel takes too long or ends in invalid state
     * @throws OperationFailedException if time travel fails
     */
    public TimeMachine waitForTimeTravelCompletion(TimeMachine timeMachine)
            throws ChargebeeException, InterruptedException {
        return waitForTimeTravelCompletion(timeMachine.getName());
    }
    
    /**
     * Waits for time travel operation to complete.
     * Polls the API until the status changes from IN_PROGRESS.
     *
     * @param timeMachineName The name of the TimeMachine to wait for
     * @return The updated TimeMachine with final status
     * @throws ChargebeeException if the API call fails
     * @throws InterruptedException if the thread is interrupted while waiting
     * @throws RuntimeException if time travel takes too long or ends in invalid state
     * @throws OperationFailedException if time travel fails
     */
    public TimeMachine waitForTimeTravelCompletion(String timeMachineName)
            throws ChargebeeException, InterruptedException {
        int count = 0;
        int sleepTime = Integer.getInteger("cb.java.time_travel.sleep.millis", 3000);
        TimeMachine timeMachine = retrieve(timeMachineName).getTimeMachine();
        
        while (timeMachine.getTimeTravelStatus() == TimeTravelStatus.IN_PROGRESS) {
            if (count++ > 30) {
                throw new RuntimeException("The time travel is taking too much time");
            }
            Thread.sleep(sleepTime);
            timeMachine = retrieve(timeMachineName).getTimeMachine();
        }
        
        if (timeMachine.getTimeTravelStatus() == TimeTravelStatus.FAILED) {
            String errorJson = timeMachine.getErrorJson();
            int httpStatusCode = JsonUtil.getInteger(errorJson, "http_code");
            String exceptionMessage = JsonUtil.getString(errorJson, "message");
            throw new OperationFailedException(
                httpStatusCode,
                "operation_failed",
                BadRequestApiErrorCode._UNKNOWN,
                exceptionMessage,
                errorJson,
                null,
                null
            );
        }
        
        if (timeMachine.getTimeTravelStatus() == TimeTravelStatus.NOT_ENABLED
                || timeMachine.getTimeTravelStatus() == TimeTravelStatus._UNKNOWN) {
            throw new RuntimeException("Time travel status is in wrong state: " 
                + timeMachine.getTimeTravelStatus());
        }
        
        return timeMachine;
    }
{{/if}}
}