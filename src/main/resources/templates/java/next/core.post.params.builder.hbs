/*
 * This file is auto-generated by Chargebee.
 * For more information on how to make changes to this file, please see the README.
 * Reach out to dx@chargebee.com for any questions.
 * Copyright 2025 Chargebee Inc.
 */
package com.chargebee.v4.models.{{module}}.params;

import com.chargebee.v4.internal.Recommended;
import com.chargebee.v4.internal.JsonUtil;
import com.chargebee.v4.filters.StringFilter;
import com.chargebee.v4.filters.NumberFilter;
import com.chargebee.v4.filters.TimestampFilter;
import com.chargebee.v4.filters.EnumFilter;
import com.chargebee.v4.filters.BooleanFilter;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;
import java.util.function.Consumer;
import java.sql.Timestamp;
import java.util.stream.Collectors;


public final class {{name}}Params {
{{>paramsContent this}}

    {{#each subModels}}
    public static final class {{name}}Params {
{{>paramsContent this}}
    }
    {{/each}}
}

{{#*inline "paramsContent"}}
    {{#each fields}}
    {{#unless isFilter}}
    private final {{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} {{name}};
    {{/unless}}
    {{/each}}
    {{#if hasFilterFields}}
    private final Map<String, Object> filterParams;
    {{/if}}
    {{#if customFieldsSupported}}
    private final Map<String, String> customFields;
    {{/if}}
    {{#if consentFieldsSupported}}
    private final Map<String, Object> consentFields;
    {{/if}}

    private {{name}}Params({{name}}Builder builder) {
        {{#each fields}}
        {{#unless isFilter}}
        this.{{name}} = builder.{{name}};
        {{/unless}}
        {{/each}}
        {{#if hasFilterFields}}
        this.filterParams = builder.filterParams.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(new LinkedHashMap<>(builder.filterParams));
        {{/if}}
        {{#if customFieldsSupported}}
        this.customFields = builder.customFields.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(new LinkedHashMap<>(builder.customFields));
        {{/if}}
        {{#if consentFieldsSupported}}
        this.consentFields = builder.consentFields.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(new LinkedHashMap<>(builder.consentFields));
        {{/if}}
    }

    {{#each fields}}
    {{#unless isFilter}}
    public {{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} {{getterName}}() {
        return {{name}};
    }
    {{/unless}}
    {{/each}}
    {{#if customFieldsSupported}}
    public Map<String, String> customFields() {
        return customFields;
    }
    {{/if}}
    {{#if consentFieldsSupported}}
    public Map<String, Object> consentFields() {
        return consentFields;
    }
    {{/if}}

    /**
     * Get the form data for this request.
     */
    public Map<String, Object> toFormData() {
        Map<String, Object> formData = new LinkedHashMap<>();

        {{#each fields}}
        {{#unless isFilter}}
        if (this.{{name}} != null) {
            {{#if subModelField}}
                {{#if compositeArrayField}}
                // List of objects
                for (int i = 0; i < this.{{name}}.size(); i++) {
                    {{subModelParamsType}} item = this.{{name}}.get(i);
                    if (item != null) {
                        Map<String, Object> itemData = item.toFormData();
                        for (Map.Entry<String, Object> entry : itemData.entrySet()) {
                            {{~#if subModelHasFilterFields}}
                            String key = entry.getKey();
                            String indexedKey = key.contains("[") 
                                ? "{{curlName}}[" + key.replace("[", "][") + "[" + i + "]"
                                : "{{curlName}}[" + key + "][" + i + "]";
                            formData.put(indexedKey, entry.getValue());
                            {{~else}}
                            String indexedKey = "{{curlName}}[" + entry.getKey() + "][" + i + "]";
                            formData.put(indexedKey, entry.getValue());
                            {{~/if}}
                        }
                    }
                }
                {{else}}
                // Single object
                Map<String, Object> nestedData = this.{{name}}.toFormData();
                for (Map.Entry<String, Object> entry : nestedData.entrySet()) {
                    {{~#if subModelHasFilterFields}}
                    String key = entry.getKey();
                    String nestedKey = key.contains("[") 
                        ? "{{curlName}}[" + key.replace("[", "][") 
                        : "{{curlName}}[" + key + "]";
                    formData.put(nestedKey, entry.getValue());
                    {{~else}}
                    String nestedKey = "{{curlName}}[" + entry.getKey() + "]";
                    formData.put(nestedKey, entry.getValue());
                    {{~/if}}
                }
                {{/if}}
            {{else}}
                {{#if mapType}}
                formData.put("{{curlName}}", JsonUtil.toJson(this.{{name}}));
                {{else if isListType}}
                    {{#if (or (eq listElementType "Object") (eq listElementType "java.util.Map<String, Object>"))}}
                    formData.put("{{curlName}}", JsonUtil.toJson(this.{{name}}));
                    {{else}}
                    formData.put("{{curlName}}", this.{{name}});
                    {{/if}}
                {{else}}
                formData.put("{{curlName}}", this.{{name}});
                {{/if}}
            {{/if}}
        }
        {{/unless}}
        {{/each}}
        
        {{#if hasFilterFields}}
        // Add filter params
        formData.putAll(filterParams);
        {{/if}}
        
        {{#if customFieldsSupported}}
        formData.putAll(customFields);
        {{/if}}
        {{#if consentFieldsSupported}}
        formData.putAll(consentFields);
        {{/if}}

        return formData;
    }

    /**
     * Create a new builder for {{name}}Params.
     */
    @Recommended(reason = "Preferred for reusability, validation, and LLM-friendliness")
    public static {{name}}Builder builder() {
        return new {{name}}Builder();
    }

    public static final class {{name}}Builder {
        {{#each fields}}
        {{#unless isFilter}}
        private {{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} {{name}};
        {{/unless}}
        {{/each}}
        {{#if hasFilterFields}}
        private final Map<String, Object> filterParams = new LinkedHashMap<>();
        {{/if}}
        {{#if customFieldsSupported}}
        private Map<String, String> customFields = new LinkedHashMap<>();
        {{/if}}
        {{#if consentFieldsSupported}}
        private Map<String, Object> consentFields = new LinkedHashMap<>();
        {{/if}}

        private {{name}}Builder() {}

        {{#each fields}}
        {{#if isFilter}}{{#if deprecated}}
        @Deprecated
{{/if}}        public {{filterType}} {{name}}() {
            return new {{filterType}}("{{curlName}}", this, filterParams);
        }
        {{else}}{{#if deprecated}}
        @Deprecated
{{/if}}        public {{../name}}Builder {{name}}({{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} value) {
            this.{{name}} = value;
            return this;
        }
        {{/if}}
        {{/each}}
        {{#if customFieldsSupported}}

        /**
         * Add a custom field to the request. Custom fields must start with "cf_".
         *
         * @param fieldName the name of the custom field (e.g., "cf_custom_field_name")
         * @param value the value of the custom field
         * @return this builder
         * @throws IllegalArgumentException if fieldName doesn't start with "cf_"
         */
        public {{name}}Builder customField(String fieldName, String value) {
            if (fieldName == null || !fieldName.startsWith("cf_")) {
                throw new IllegalArgumentException("Custom field name must start with 'cf_'");
            }
            this.customFields.put(fieldName, value);
            return this;
        }

        /**
         * Add multiple custom fields to the request. All field names must start with "cf_".
         *
         * @param customFields map of custom field names to values
         * @return this builder
         * @throws IllegalArgumentException if any field name doesn't start with "cf_"
         */
        public {{name}}Builder customFields(Map<String, String> customFields) {
            if (customFields != null) {
                for (Map.Entry<String, String> entry : customFields.entrySet()) {
                    if (entry.getKey() == null || !entry.getKey().startsWith("cf_")) {
                        throw new IllegalArgumentException("Custom field name must start with 'cf_': " + entry.getKey());
                    }
                    this.customFields.put(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        {{/if}}
        {{#if consentFieldsSupported}}

        /**
         * Add a consent field to the request. Consent fields must start with "cs_".
         * Consent fields typically hold boolean values or options.
         *
         * @param fieldName the name of the consent field (e.g., "cs_marketing_consent")
         * @param value the value of the consent field (typically Boolean or String for options)
         * @return this builder
         * @throws IllegalArgumentException if fieldName doesn't start with "cs_"
         */
        public {{name}}Builder consentField(String fieldName, Object value) {
            if (fieldName == null || !fieldName.startsWith("cs_")) {
                throw new IllegalArgumentException("Consent field name must start with 'cs_'");
            }
            this.consentFields.put(fieldName, value);
            return this;
        }

        /**
         * Add a boolean consent field to the request. Consent fields must start with "cs_".
         *
         * @param fieldName the name of the consent field (e.g., "cs_marketing_consent")
         * @param value the boolean value of the consent field
         * @return this builder
         * @throws IllegalArgumentException if fieldName doesn't start with "cs_"
         */
        public {{name}}Builder consentField(String fieldName, Boolean value) {
            if (fieldName == null || !fieldName.startsWith("cs_")) {
                throw new IllegalArgumentException("Consent field name must start with 'cs_'");
            }
            this.consentFields.put(fieldName, value);
            return this;
        }

        /**
         * Add multiple consent fields to the request. All field names must start with "cs_".
         *
         * @param consentFields map of consent field names to values
         * @return this builder
         * @throws IllegalArgumentException if any field name doesn't start with "cs_"
         */
        public {{name}}Builder consentFields(Map<String, Object> consentFields) {
            if (consentFields != null) {
                for (Map.Entry<String, Object> entry : consentFields.entrySet()) {
                    if (entry.getKey() == null || !entry.getKey().startsWith("cs_")) {
                        throw new IllegalArgumentException("Consent field name must start with 'cs_': " + entry.getKey());
                    }
                    this.consentFields.put(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        {{/if}}

        public {{name}}Params build() {
            return new {{name}}Params(this);
        }

        {{#each fields}}
        {{#if isFilter}}
        {{#if hasFilterEnum}}
        public static final class {{filterType}} extends EnumFilter<{{filterEnumType}}, {{../name}}Builder> {
            {{filterType}}(String fieldName, {{../name}}Builder builder, Map<String, Object> params) {
                super(fieldName, builder, params, {{filterEnumType}}::getValue);
            }

            /**
             * @deprecated This method accepting raw String will be removed in a future version.
             * Use the type-safe enum overload instead:
             * <pre>{@code .{{name}}().is({{filterEnumType}}.YOUR_VALUE)}</pre>
             * @see #is({{filterEnumType}})
             */
            @Deprecated
            public {{../name}}Builder is(String value) {
                params.put(fieldName + "[is]", value);
                return builder;
            }

            /**
             * @deprecated This method accepting raw String will be removed in a future version.
             * Use the type-safe enum overload instead:
             * <pre>{@code .{{name}}().isNot({{filterEnumType}}.YOUR_VALUE)}</pre>
             * @see #isNot({{filterEnumType}})
             */
            @Deprecated
            public {{../name}}Builder isNot(String value) {
                params.put(fieldName + "[is_not]", value);
                return builder;
            }

            /**
             * @deprecated This method accepting raw String will be removed in a future version.
             * Use the type-safe enum overload instead:
             * <pre>{@code .{{name}}().in({{filterEnumType}}.VALUE1, {{filterEnumType}}.VALUE2)}</pre>
             * @see #in({{filterEnumType}}[])
             */
            @Deprecated
            public {{../name}}Builder in(String... values) {
                params.put(fieldName + "[in]", "[" + String.join(",", values) + "]");
                return builder;
            }

            /**
             * @deprecated This method accepting raw String will be removed in a future version.
             * Use the type-safe enum overload instead:
             * <pre>{@code .{{name}}().notIn({{filterEnumType}}.VALUE1, {{filterEnumType}}.VALUE2)}</pre>
             * @see #notIn({{filterEnumType}}[])
             */
            @Deprecated
            public {{../name}}Builder notIn(String... values) {
                params.put(fieldName + "[not_in]", "[" + String.join(",", values) + "]");
                return builder;
            }
        }
        {{else if numberFilter}}
        public static final class {{filterType}} extends NumberFilter<{{../name}}Builder> {
            {{filterType}}(String fieldName, {{../name}}Builder builder, Map<String, Object> params) {
                super(fieldName, builder, params);
            }
        }
        {{else if timestampFilter}}
        public static final class {{filterType}} extends TimestampFilter<{{../name}}Builder> {
            {{filterType}}(String fieldName, {{../name}}Builder builder, Map<String, Object> params) {
                super(fieldName, builder, params);
            }
        }
        {{else if booleanFilter}}
        public static final class {{filterType}} extends BooleanFilter<{{../name}}Builder> {
            {{filterType}}(String fieldName, {{../name}}Builder builder, Map<String, Object> params) {
                super(fieldName, builder, params);
            }

            /**
             * @deprecated This method accepting raw String will be removed in a future version.
             * Use the type-safe boolean overload instead:
             * <pre>{@code .{{name}}().is(true)}</pre>
             * @see #is(boolean)
             */
            @Deprecated
            public {{../name}}Builder is(String value) {
                params.put(fieldName + "[is]", value);
                return builder;
            }
        }
        {{else}}
        public static final class {{filterType}} extends StringFilter<{{../name}}Builder> {
            {{filterType}}(String fieldName, {{../name}}Builder builder, Map<String, Object> params) {
                super(fieldName, builder, params);
            }
        }
        {{/if}}
        {{/if}}
        {{/each}}
    }

    {{#each enumFields}}
    public enum {{name}} {
        {{#each values}}
        {{this.key}}("{{this.value}}"),
        {{/each}}
        /**
            * An enum member indicating that {{name}} was instantiated with an unknown
            * value.
            */
        _UNKNOWN(null);
        private final String value;

        {{name}}(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        public static {{name}} fromString(String value) {
            if (value == null) return _UNKNOWN;
            for ({{name}} enumValue : {{name}}.values()) {
                if (enumValue.value != null && enumValue.value.equals(value)) {
                    return enumValue;
                }
            }
            return _UNKNOWN;
        }
    }
    {{/each}}

    {{#each fields}}
    {{#if isFilter}}
    {{#if hasFilterEnum}}
    public enum {{filterEnumType}} {
        {{#each filterEnumFormatted}}
        {{this.key}}("{{this.value}}"),
        {{/each}}
        /**
            * An enum member indicating that {{filterEnumType}} was instantiated with an unknown
            * value.
            */
        _UNKNOWN(null);
        private final String value;

        {{filterEnumType}}(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        public static {{filterEnumType}} fromString(String value) {
            if (value == null) return _UNKNOWN;
            for ({{filterEnumType}} enumValue : {{filterEnumType}}.values()) {
                if (enumValue.value != null && enumValue.value.equals(value)) {
                    return enumValue;
                }
            }
            return _UNKNOWN;
        }
    }
    {{/if}}
    {{/if}}
    {{/each}}
{{/inline}}
