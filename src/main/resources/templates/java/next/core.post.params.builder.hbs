/*
 * This file is auto-generated by Chargebee.
 * For more information on how to make changes to this file, please see the README.
 * Reach out to dx@chargebee.com for any questions.
 * Copyright 2025 Chargebee Inc.
 */
package com.chargebee.v4.models.{{module}}.params;

import com.chargebee.v4.internal.Recommended;
import com.chargebee.v4.internal.JsonUtil;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.List;
import java.util.function.Consumer;
import java.sql.Timestamp;


public final class {{name}}Params {
{{>paramsContent this}}

    {{#each subModels}}
    public static final class {{name}}Params {
{{>paramsContent this}}
    }
    {{/each}}
}

{{#*inline "paramsContent"}}
    {{#each fields}}
    private final {{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} {{name}};
    {{/each}}
    {{#if customFieldsSupported}}
    private final Map<String, Object> customFields;
    {{/if}}
    {{#if consentFieldsSupported}}
    private final Map<String, Object> consentFields;
    {{/if}}

    private {{name}}Params({{name}}Builder builder) {
        {{#each fields}}
        this.{{name}} = builder.{{name}};
        {{/each}}
        {{#if customFieldsSupported}}
        this.customFields = builder.customFields.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(new LinkedHashMap<>(builder.customFields));
        {{/if}}
        {{#if consentFieldsSupported}}
        this.consentFields = builder.consentFields.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(new LinkedHashMap<>(builder.consentFields));
        {{/if}}
    }

    {{#each fields}}
    public {{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} {{getterName}}() {
        return {{name}};
    }
    {{/each}}
    {{#if customFieldsSupported}}
    public Map<String, Object> customFields() {
        return customFields;
    }
    {{/if}}
    {{#if consentFieldsSupported}}
    public Map<String, Object> consentFields() {
        return consentFields;
    }
    {{/if}}

    /**
     * Get the form data for this request.
     */
    public Map<String, Object> toFormData() {
        Map<String, Object> formData = new LinkedHashMap<>();

        {{#each fields}}
        if (this.{{name}} != null) {
            {{#if subModelField}}
                {{#if compositeArrayField}}
                // List of objects
                for (int i = 0; i < this.{{name}}.size(); i++) {
                    {{subModelParamsType}} item = this.{{name}}.get(i);
                    if (item != null) {
                        Map<String, Object> itemData = item.toFormData();
                        for (Map.Entry<String, Object> entry : itemData.entrySet()) {
                            String indexedKey = "{{curlName}}[" + entry.getKey() + "][" + i + "]";
                            formData.put(indexedKey, entry.getValue());
                        }
                    }
                }
                {{else}}
                // Single object
                Map<String, Object> nestedData = this.{{name}}.toFormData();
                for (Map.Entry<String, Object> entry : nestedData.entrySet()) {
                    String nestedKey = "{{curlName}}[" + entry.getKey() + "]";
                    formData.put(nestedKey, entry.getValue());
                }
                {{/if}}
            {{else}}
                {{#if mapType}}
                formData.put("{{curlName}}", JsonUtil.toJson(this.{{name}}));
                {{else if isListType}}
                    {{#if (or (eq listElementType "Object") (eq listElementType "java.util.Map<String, Object>"))}}
                    formData.put("{{curlName}}", JsonUtil.toJson(this.{{name}}));
                    {{else}}
                    formData.put("{{curlName}}", this.{{name}});
                    {{/if}}
                {{else}}
                formData.put("{{curlName}}", this.{{name}});
                {{/if}}
            {{/if}}
        }
        {{/each}}
        
        {{#if customFieldsSupported}}
        formData.putAll(customFields);
        {{/if}}
        {{#if consentFieldsSupported}}
        formData.putAll(consentFields);
        {{/if}}

        return formData;
    }

    /**
     * Create a new builder for {{name}}Params.
     */
    @Recommended(reason = "Preferred for reusability, validation, and LLM-friendliness")
    public static {{name}}Builder builder() {
        return new {{name}}Builder();
    }

    public static final class {{name}}Builder {
        {{#each fields}}
        private {{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} {{name}};
        {{/each}}
        {{#if customFieldsSupported}}
        private Map<String, Object> customFields = new LinkedHashMap<>();
        {{/if}}
        {{#if consentFieldsSupported}}
        private Map<String, Object> consentFields = new LinkedHashMap<>();
        {{/if}}

        private {{name}}Builder() {}

        {{#each fields}}
        {{#if deprecated}}@Deprecated{{/if}}
        public {{../name}}Builder {{name}}({{#if subModelField}}{{#if compositeArrayField}}List<{{subModelParamsType}}>{{else}}{{subModelParamsType}}{{/if}}{{else}}{{{type}}}{{/if}} value) {
            this.{{name}} = value;
            return this;
        }
        {{/each}}
        {{#if customFieldsSupported}}

        /**
         * Add a custom field to the request. Custom fields must start with "cf_".
         *
         * @param fieldName the name of the custom field (e.g., "cf_custom_field_name")
         * @param value the value of the custom field
         * @return this builder
         * @throws IllegalArgumentException if fieldName doesn't start with "cf_"
         */
        public {{name}}Builder customField(String fieldName, Object value) {
            if (fieldName == null || !fieldName.startsWith("cf_")) {
                throw new IllegalArgumentException("Custom field name must start with 'cf_'");
            }
            this.customFields.put(fieldName, value);
            return this;
        }

        /**
         * Add multiple custom fields to the request. All field names must start with "cf_".
         *
         * @param customFields map of custom field names to values
         * @return this builder
         * @throws IllegalArgumentException if any field name doesn't start with "cf_"
         */
        public {{name}}Builder customFields(Map<String, Object> customFields) {
            if (customFields != null) {
                for (Map.Entry<String, Object> entry : customFields.entrySet()) {
                    if (entry.getKey() == null || !entry.getKey().startsWith("cf_")) {
                        throw new IllegalArgumentException("Custom field name must start with 'cf_': " + entry.getKey());
                    }
                    this.customFields.put(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        {{/if}}
        {{#if consentFieldsSupported}}

        /**
         * Add a consent field to the request. Consent fields must start with "cs_".
         * Consent fields typically hold boolean values or options.
         *
         * @param fieldName the name of the consent field (e.g., "cs_marketing_consent")
         * @param value the value of the consent field (typically Boolean or String for options)
         * @return this builder
         * @throws IllegalArgumentException if fieldName doesn't start with "cs_"
         */
        public {{name}}Builder consentField(String fieldName, Object value) {
            if (fieldName == null || !fieldName.startsWith("cs_")) {
                throw new IllegalArgumentException("Consent field name must start with 'cs_'");
            }
            this.consentFields.put(fieldName, value);
            return this;
        }

        /**
         * Add a boolean consent field to the request. Consent fields must start with "cs_".
         *
         * @param fieldName the name of the consent field (e.g., "cs_marketing_consent")
         * @param value the boolean value of the consent field
         * @return this builder
         * @throws IllegalArgumentException if fieldName doesn't start with "cs_"
         */
        public {{name}}Builder consentField(String fieldName, Boolean value) {
            if (fieldName == null || !fieldName.startsWith("cs_")) {
                throw new IllegalArgumentException("Consent field name must start with 'cs_'");
            }
            this.consentFields.put(fieldName, value);
            return this;
        }

        /**
         * Add multiple consent fields to the request. All field names must start with "cs_".
         *
         * @param consentFields map of consent field names to values
         * @return this builder
         * @throws IllegalArgumentException if any field name doesn't start with "cs_"
         */
        public {{name}}Builder consentFields(Map<String, Object> consentFields) {
            if (consentFields != null) {
                for (Map.Entry<String, Object> entry : consentFields.entrySet()) {
                    if (entry.getKey() == null || !entry.getKey().startsWith("cs_")) {
                        throw new IllegalArgumentException("Consent field name must start with 'cs_': " + entry.getKey());
                    }
                    this.consentFields.put(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        {{/if}}

        public {{name}}Params build() {
            return new {{name}}Params(this);
        }
    }

    {{#each enumFields}}
    public enum {{name}} {
        {{#each values}}
        {{this.key}}("{{this.value}}"),
        {{/each}}
        /**
            * An enum member indicating that {{name}} was instantiated with an unknown
            * value.
            */
        _UNKNOWN(null);
        private final String value;

        {{name}}(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        public static {{name}} fromString(String value) {
            if (value == null) return _UNKNOWN;
            for ({{name}} enumValue : {{name}}.values()) {
                if (enumValue.value != null && enumValue.value.equals(value)) {
                    return enumValue;
                }
            }
            return _UNKNOWN;
        }
    }
    {{/each}}
{{/inline}}
