/*
 * This file is auto-generated by Chargebee.
 * For more information on how to make changes to this file, please see the README.
 * Reach out to dx@chargebee.com for any questions.
 * Copyright 2025 Chargebee Inc.
 */

package com.chargebee.v4.models.{{packageName}};

import com.chargebee.v4.internal.JsonUtil;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.List;
{{#each imports}}
import {{this}};
{{/each}}

public class {{name}} {
{{>modelContent this}}
}

{{#*inline "modelContent"}}
{{#each fields}}{{#if deprecated}}@Deprecated{{/if}}
private {{{type}}} {{name}};{{/each}}
{{#if customFieldsSupported}}
private java.util.Map<String, String> customFields = new java.util.HashMap<>();{{/if}}
{{#if consentFieldsSupported}}
private java.util.Map<String, Object> consentFields = new java.util.HashMap<>();{{/if}}
{{#each fields}}
{{#if deprecated}}
@Deprecated
{{/if}}  public {{{type}}} {{getterName}}() {
  return {{name}};
}
{{/each}}
{{#if customFieldsSupported}}
  /**
   * Returns a map of custom fields. Custom fields are dynamic properties that
   * follow the pattern cf_* (e.g., cf_custom_field_name).
   *
   * @return map containing all custom fields
   */
  public java.util.Map<String, String> getCustomFields() {
    return customFields;
  }

  /**
   * Returns the value of a specific custom field.
   *
   * @param fieldName the name of the custom field (e.g., "cf_custom_field_name")
   * @return the value of the custom field, or null if not present
   */
  public String getCustomField(String fieldName) {
    return customFields.get(fieldName);
  }
{{/if}}
{{#if consentFieldsSupported}}
  /**
   * Returns a map of consent fields. Consent fields are dynamic boolean/option properties
   * that follow the pattern cs_* (e.g., cs_marketing_consent).
   *
   * @return map containing all consent fields
   */
  public java.util.Map<String, Object> getConsentFields() {
    return consentFields;
  }

  /**
   * Returns the value of a specific consent field.
   *
   * @param fieldName the name of the consent field (e.g., "cs_marketing_consent")
   * @return the value of the consent field, or null if not present
   */
  public Object getConsentField(String fieldName) {
    return consentFields.get(fieldName);
  }

  /**
   * Returns the boolean value of a specific consent field.
   *
   * @param fieldName the name of the consent field (e.g., "cs_marketing_consent")
   * @return the boolean value of the consent field, or null if not present or not a boolean
   */
  public Boolean getConsentFieldAsBoolean(String fieldName) {
    Object value = consentFields.get(fieldName);
    if (value instanceof Boolean) {
      return (Boolean) value;
    }
    return null;
  }
{{/if}}
{{#each enumFields}}
  public enum {{name}} {
    {{#each values}}
      {{this.key}}("{{this.value}}"),
    {{/each}}
     /**
        * An enum member indicating that {{name}} was instantiated with an unknown
        * value.
        */
    _UNKNOWN(null);
    private final String value;

    {{name}}(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public static {{name}} fromString(String value) {
        if (value == null) return _UNKNOWN;
        for ({{name}} enumValue : {{name}}.values()) {
            if (enumValue.value != null && enumValue.value.equals(value)) {
                return enumValue;
            }
        }
        return _UNKNOWN;
    }
  }
{{/each}}
 public static {{name}} fromJson(String json) {
  {{name}} obj = new {{name}}();
  {{#if customFieldsSupported}}
  // Parse JSON to extract all keys for custom field extraction
  java.util.Set<String> knownFields = new java.util.HashSet<>();
  {{#each fields}}
  knownFields.add("{{curlName}}");
  {{/each}}
  {{else if consentFieldsSupported}}
  // Parse JSON to extract all keys for consent field extraction
  java.util.Set<String> knownFields = new java.util.HashSet<>();
  {{#each fields}}
  knownFields.add("{{curlName}}");
  {{/each}}
  {{/if}}

  {{#each fields}}
  {{#if isMapType}}
  String __{{name}}Json = JsonUtil.getObject(json, "{{curlName}}");
  obj.{{name}} = __{{name}}Json != null ? JsonUtil.parseJsonObjectToMap(__{{name}}Json) : new java.util.HashMap<>();
  {{else if isComplexObjectType}}
  String __{{name}}Json = JsonUtil.getObject(json, "{{curlName}}");
  if (__{{name}}Json != null) {
  obj.{{name}} = {{type}}.fromJson(__{{name}}Json);
  }
  {{else if isObjectType}}
  {{#if isPlainObjectType}}
  obj.{{name}} = JsonUtil.getObject(json, "{{curlName}}");
  {{else}}
  String __{{name}}Json = JsonUtil.getObject(json, "{{curlName}}");
  if (__{{name}}Json != null) {
  obj.{{name}} = {{type}}.fromJson(__{{name}}Json);
  }
  {{/if}}
  {{else if isEnumType}}
  obj.{{name}} = {{type}}.fromString(JsonUtil.getString(json, "{{curlName}}"));
  {{else if isListOfObjects}}
  obj.{{name}} = JsonUtil.parseObjectArray(JsonUtil.getArray(json, "{{curlName}}")).stream().map({{listElementType}}::fromJson).collect(java.util.stream.Collectors.toList());
  {{else if isListType}}
  {{#if (eq listElementType "Object")}}
  String __{{name}}Json = JsonUtil.getArray(json, "{{curlName}}");
  obj.{{name}} = __{{name}}Json != null ?
      JsonUtil.parseObjectArray(__{{name}}Json).stream()
          .map(JsonUtil::parseJsonObjectToMap)
          .collect(java.util.stream.Collectors.toList()) : null;
  {{else if (eq listElementType "java.util.Map<String, Object>")}}
  String __{{name}}Json = JsonUtil.getArray(json, "{{curlName}}");
  obj.{{name}} = __{{name}}Json != null ?
      JsonUtil.parseObjectArray(__{{name}}Json).stream()
          .map(JsonUtil::parseJsonObjectToMap)
          .collect(java.util.stream.Collectors.toList()) : null;
  {{else}}
  obj.{{name}} = JsonUtil.parseArrayOfString(JsonUtil.getArray(json, "{{curlName}}"));
  {{/if}}
  {{else}}
  obj.{{name}} = JsonUtil.get{{type}}(json, "{{curlName}}");
  {{/if}}
  {{/each}}
  {{#if customFieldsSupported}}
  // Extract custom fields (fields starting with cf_)
  obj.customFields = extractCustomFields(json, knownFields);
  {{/if}}
  {{#if consentFieldsSupported}}
  // Extract consent fields (fields starting with cs_)
  obj.consentFields = extractConsentFields(json, knownFields);
  {{/if}}
  return obj;
 }
{{#if customFieldsSupported}}

 /**
  * Helper method to extract custom fields from JSON.
  * Custom fields are fields that start with "cf_" and are not in the known fields set.
  *
  * @param json JSON string to parse
  * @param knownFields set of known field names
  * @return map of custom fields
  */
 private static java.util.Map<String, String> extractCustomFields(String json, java.util.Set<String> knownFields) {
  java.util.Map<String, String> customFields = new java.util.HashMap<>();
  try {
    // Parse the entire JSON as a map
    java.util.Map<String, Object> allFields = JsonUtil.parseJsonObjectToMap(json);
    if (allFields != null) {
      for (java.util.Map.Entry<String, Object> entry : allFields.entrySet()) {
        String key = entry.getKey();
        // Include fields that start with "cf_" and are not in knownFields
        if (key != null && key.startsWith("cf_") && !knownFields.contains(key)) {
          customFields.put(key, entry.getValue() != null ? String.valueOf(entry.getValue()) : null);
        }
      }
    }
  } catch (Exception e) {
    // If parsing fails, return empty map
  }
  return customFields;
 }
{{/if}}
{{#if consentFieldsSupported}}

 /**
  * Helper method to extract consent fields from JSON.
  * Consent fields are fields that start with "cs_" and are not in the known fields set.
  * They typically contain boolean values or options.
  *
  * @param json JSON string to parse
  * @param knownFields set of known field names
  * @return map of consent fields
  */
 private static java.util.Map<String, Object> extractConsentFields(String json, java.util.Set<String> knownFields) {
  java.util.Map<String, Object> consentFields = new java.util.HashMap<>();
  try {
    // Parse the entire JSON as a map
    java.util.Map<String, Object> allFields = JsonUtil.parseJsonObjectToMap(json);
    if (allFields != null) {
      for (java.util.Map.Entry<String, Object> entry : allFields.entrySet()) {
        String key = entry.getKey();
        // Include fields that start with "cs_" and are not in knownFields
        if (key != null && key.startsWith("cs_") && !knownFields.contains(key)) {
          consentFields.put(key, entry.getValue());
        }
      }
    }
  } catch (Exception e) {
    // If parsing fails, return empty map
  }
  return consentFields;
 }
{{/if}}

 @Override
 public String toString() {
  return "{{name}}{" +
  {{#each fields}}
    "{{#unless @first}}, {{/unless}}{{name}}=" + {{name}} +
  {{/each}}
  {{#if customFieldsSupported}}
    ", customFields=" + customFields +
  {{/if}}
  {{#if consentFieldsSupported}}
    ", consentFields=" + consentFields +
  {{/if}}
    "}";
 }

 @Override
 public boolean equals(Object o) {
  if (this == o) return true;
  if (o == null || getClass() != o.getClass()) return false;
  {{#if fields}}
  {{name}} that = ({{name}}) o;
  return {{#each fields}}java.util.Objects.equals({{name}}, that.{{name}}){{#unless @last}} &&
    {{/unless}}{{/each}}{{#if customFieldsSupported}} &&
    java.util.Objects.equals(customFields, that.customFields){{/if}}{{#if consentFieldsSupported}} &&
    java.util.Objects.equals(consentFields, that.consentFields){{/if}};
  {{else if customFieldsSupported}}
  {{name}} that = ({{name}}) o;
  return java.util.Objects.equals(customFields, that.customFields);
  {{else if consentFieldsSupported}}
  {{name}} that = ({{name}}) o;
  return java.util.Objects.equals(consentFields, that.consentFields);
  {{else}}
  return true;
  {{/if}}
 }

 @Override
 public int hashCode() {
  {{#if fields}}
  return java.util.Objects.hash({{#each fields}}{{name}}{{#unless @last}}, {{/unless}}{{/each}}{{#if customFieldsSupported}}, customFields{{/if}}{{#if consentFieldsSupported}}, consentFields{{/if}});
  {{else if customFieldsSupported}}
  return java.util.Objects.hash(customFields);
  {{else if consentFieldsSupported}}
  return java.util.Objects.hash(consentFields);
  {{else}}
  return 0;
  {{/if}}
 }

{{#each subModels}}
  public static class {{name}} {
{{>modelContent this}}
  }
{{/each}}
{{/inline}}